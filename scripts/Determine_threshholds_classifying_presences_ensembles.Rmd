---
title: "Determine cutoff threadholds for classifying presences in ensembles"
author: "steppe"
date: "3/17/2022"
output: pdf_document
---



```{r load libraries, results='hide', message=F, warning=F}
library(tidyverse) # data tidying
library(sf) # spatial data compliant with tidyverse
library(raster) # raster data
library(here)
library(rgbif)

source(here::here('scripts/sdm_functions.R'))
set.seed(12)
```


```{r Create Raster Stack of Predictons}
predictions_stack <- paste0(here(), '/results/maps/',
list.files(paste0(here(), '/results/maps/'),
           pattern = "*.tif$" ))
predictions_stack <- raster::stack(predictions_stack)
```

We will use the ecoregion bound to query GBIF for more presence records for testing ensembles for prediction thresholds. We will also used the records which were removed from the intial BIEN data due to high levels of spatial auto-correlation. 
```{r Import Pruned Occurrence Records for Presences}
pseudo_abs <- st_read(paste0(here(), '/data/processed/Pseudo_absences_regression.shp'), 
                      quiet = T)[,c(1:4,21)]
recs_rm_spatial_auto <- pseudo_abs %>% filter(occurrence == 2)
true_recs <- pseudo_abs %>% filter(!is.na(PlotKey) | occurrence == 1 | occurrence == 2)
  
ecoregion_bound <- st_read(paste0(here(),'/data/processed/SoRo_ecoregion_bound.shp'))
```

We will also import the AIM dataset to feed in more true absences. 
```{r Import BLM data for more True Absence Records}
AIM <- st_read(paste0(here(),'/data/processed/AIM_Records_study_area.shp'), quiet = T)
```

We will scrape GBIF for some new records to test our preidcictions against. 
```{r check GBIF for new presence records, eval = F}
wkt_boundary <-  ecoregion_bound %>%  
  st_transform(4326) %>% 
  dplyr::select(ncol(.)) %>% 
  st_bbox()

species_vec <- true_recs %>% distinct(binomial) %>% pull(binomial) %>% 
  gsub("_", " ", .)

gbif_results_raw <-  lapply(species_vec, gbif_collector)
gbif_results_raw <- gbif_results_raw %>% 
  bind_rows() %>% 
  st_as_sf(coords = c(x = 'decimalLongitude', y = 'decimalLatitude'), 
           crs = 4326)

# st_write(gbif_results_raw, paste0(here(),'/data/raw/gbif_data.shp'))
rm(wkt_boundary, species_vec)
rm(list=lsf.str())
```

```{r determine which GBIF records are duplicates of BIEN records, eval = F}

gbif <- st_read(paste0(here(),'/data/raw/gbif_data.shp'), quiet = T)
gbif <- gbif %>% separate(scntfcN, c("genus", "epithet"), 
                          extra = "drop", remove = F) %>% 
  unite('binomial', genus:epithet, sep = "_") %>% 
  st_transform( 32613)

true_recs <- st_transform(true_recs, 32613) %>% st_buffer(400)

true_recs_list <- split(true_recs, ~binomial)
gbif_list <-split(gbif, ~binomial)

# ensure reciprocal mathcing between datsets
gbif_list_sub <- gbif_list[which(names(gbif_list) %in% names(true_recs_list))]
true_recs_list_sub <- true_recs_list[which(names(true_recs_list) %in% names(gbif_list_sub))]

# we can then calculate st-distance between the members of the two datasets. 
results <- mapply(st_intersects, gbif_list_sub, true_recs_list_sub)
results <- map(results, tibble) 
results <- data.table::rbindlist(results)
colnames(results) <- 'Intersects'

gbif <- bind_rows(gbif_list_sub) %>% 
  cbind(., results) %>% 
  mutate(Intersects = if_else(as.character(Intersects) == "integer(0)", F, T)) %>% 
  mutate(Intersects = as.logical(Intersects)) %>% 
  filter(Intersects == F)

st_write(gbif, paste0(here(),'/data/processed/gbif_data_clean.shp'), quiet = T)

rm(true_recs_list, gbif_list, results, gbif_list_sub, true_recs_list_sub, gbif)
```


```{r followup gbif cleaning to remove duplicates, eval = F}
gbif <- st_read( paste0(here(),'/data/processed/gbif_data_clean.shp'), quiet = T)

gbif <- gbif %>% filter(occrrnS == 'PRESENT') %>% 
  st_cast('POINT') %>% 
  filter(bssOfRc %in% c('PRESERVED_SPECIMEN','HUMAN_OBSERVATION','OCCURRENCE')) %>% 
  distinct(binomial, geometry, .keep_all = T)
  
st_write(gbif, paste0(here(),'/data/processed/gbif_data_clean.shp'), quiet = T, append = F)
```

```{r join new GBIF data with thinned data and draw new absences}
gbif <- st_read( paste0(here(),'/data/processed/gbif_data_clean.shp'), quiet = T) %>% 
  dplyr::select(binomial) %>% 
  mutate(PlotKey = "") %>% 
  st_transform(predictions_stack@crs@projargs)
gbif$PlotKey <- na_if(gbif$PlotKey, "")

presences <- recs_rm_spatial_auto %>% 
  dplyr::select(binomial, PlotKey) %>% 
  st_transform(predictions_stack@crs@projargs) %>% 
  rbind(., gbif)

rm(gbif, recs_rm_spatial_auto)
```

Process united data set to assess validity for binomial logistic regression
```{r clean dataset for logistic regression}
# we need at least 10 absence and presences to run a binomial logistic regression
presences <- presences %>% 
  add_count(binomial) %>% 
  filter(n >= 10) %>% 
  dplyr::select(-n)

# should i check for spatial autocorrelation here???? - technically yes but...
```

obtain BLM absences
```{r}
AIM %>% count(PlotKey)

true_abs <- pseudo_abs %>% filter(!is.na(PlotKey))


BinLogReg_abs <- function(x, y){ # for collecting true absence records from BLM land. 
  
  #input 
  # x = dataset containing new presences
  # y = dataset containing the TRUE absences for modelling and ensembling
  
  taxon <- x %>% distinct(binomial) %>% pull(binomial)[1]
  presence_PK <- x %>% pull(PlotKey) %>%na.omit() 
  absences_PK <- y %>% pull(PlotKey) %>% na.omit()
  Pks <- c(presence_PK, absences_PK)
  samp_req <- nrow(x)
  
  AIM_to_samp <- AIM %>% # remove plots which have already been used
    filter(!PlotKey %in% Pks)  
  
  # verify that no occurrence of the taxon is in the plots to sample
  AIM_removals <- AIM_to_samp %>% 
    filter(binomial == taxon) %>% 
    distinct(PlotKey) %>% 
    pull(PlotKey) 
  # now remve the plots which could have another presence record in them
  AIM_to_samp <- AIM_to_samp %>% 
    filter(!PlotKey %in% AIM_removals)  
  
  new_absence <- AIM_to_samp[sample(1:nrow(AIM_to_samp), size =  samp_req, replace = F),]
  
  out <- rbind(x, AIM_absence)
  return(out)
}
```


```{r Extract SDM predictions to independent Presence/Absence Records}

extract_predictions <- function(eval_data, rstack ){
  
  # Inputs: eval_data = sf/tibble/dataframe of all independent 
  # species presence and absences (i.e. those not used in model dev)
  # rstack = raster stack of all ensembled predictions

  binomial <- x$binomial[1]
  
  all_GAM <- raster::subset(rstack, grep(binomial, names(my_stack), value = T))
  #values <- raster


}

```


```{r}

```



